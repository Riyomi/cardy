# [Cardy](https://www.alpha-cardy.netlify.app) - flashcard app

## Introduction

Inspired by Anki and Memrise, Cardy is a community-driven flashcard application that uses Spaced Repetition to help you learn more efficiently. Users can sign up, create their own decks or use shared ones to get started.

## Table of Contents

1. [Introduction](#introduction)
2. [The Challenge](#the-challenge)
3. [My Approach](#my-approach)
4. [Tech Used](#tech-used)
5. [Project structure](#project-structure)
6. [Feature Highlights](#feature-highlights)
7. [Future development](#future-development)

## The Challenge

Implement a full-blown flashcard application with the use of React, Express, MongoDB and GraphlQL. The main objective of the project was to deepen my understanding of the aforementioned technologies (many of which, I had limited experience before) and to streamline my workflow by learning Sass and the use of development and production variables.

[Back to the top](#cardy---flashcard-app)

## My Approach

- To design the frontend, at first I used AdobeXD but later switched to Figma because I found it easier and more intuitive to use. The early prototypes can be found [here](https://www.figma.com/file/HeyCHNLkyKEyi1CROzWf4d/Cardy?node-id=0:1). Note that it's not organized and was used only during the first phases of development, so certain parts might be missing / different in the current version.
- For planning and organizing my thoughts, I used [Todoist](https://todoist.com/) which is a free todo app. Since a recent addition, it can be used similarly to [Trello](https://trello.com/en) where you can view your tasks in a board which makes it easy to organize things visually.

  ![Example of the Cardy project during its final phase of development](https://i.imgur.com/DrepdEq.jpg)

- The development started with building the frontend in React while using the npm package json-server to fake API calls. After finishing up the pages and deciding the structure of the project, I moved onto learning GraphQL and building my own API. When I was done with a few API endpoints, I connected the frontend with the backend and from this point, both sides were developed simultaneously.

[Back to the top](#cardy---flashcard-app)

## Tech Used

### Frontend (this repo)

- HTML
- CSS (grid, flexbox, animations)
- Sass (variables, mixins)
- React (a variety of hooks, context, react-router)
- Apollo Client (for GraphQL requests)
- LocalStorage
- Figma

### [Backend](https://github.com/Riyomi/cardy-backend)

- Node
- Express
- MongoDB
- Middlewares
- HTTP only cookies
- JSON web tokens
- bcrypt (to hash passwords)
- Express GraphQL (to implement GraphlQL API endpoints)

### Deployment

- Netlify (frontend)
- Heroku (backend)

[Back to the top](#cardy---flashcard-app)

## Project Structure

<pre>
src
│ App.js
│ constants.js
| index.js
│ styles.css <-- generated by a Sass compiler  
│
└───assets
│
└───components <-- each component has its own folder with its sass file
│ │
│ └───common <-- components that don't belong to a specific page
│ │
│ └───Browse <-- components that are used only on the Browse page
│ │
│ └───DeckDetails
│ │
│ └───Home
│ │
│ └───Profile
│  
└───contexts
│  
└───pages <-- each page has its own folder with its sass file
│  
└───queries <-- GraphlQL queries and mutations in a separate folder
│  
└───sass <-- styles.scss, mixins and variables
│  
└───utils <-- general functions that are used in multiple components
</pre>

[Back to the top](#cardy---flashcard-app)

## Feature Highlights

### User session

To keep users logged in, I used the built-in React Context and created a simple custom hook to make user data available across all components.

```javascript
const UserContext = React.createContext();

export function useUser() {
  return useContext(UserContext);
}

export function UserProvider({ children }) {
  const [userInfo, setUserInfo] = useState(
    JSON.parse(localStorage.getItem('userInfo'))
  );
  return (
    <UserContext.Provider value={{ userInfo, setUserInfo }}>
      {children}
    </UserContext.Provider>
  );
}
```

To persist the data even when the app is refreshed, it is saved to localStorage after logging in along with the accessToken and its date of expiration.

```javascript
const [loginUser, { error, loading }] = useMutation(LOGIN_USER, {
  onCompleted: (data) => {
    const { user, accessToken, expires } = data.loginUser;

    localStorage.setItem('userInfo', JSON.stringify(user));
    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('expires', expires);

    setUserInfo(user);
    history.push('/dashboard');
  },
  onError: () => {},
});
```

### Access control of routes

Before the user logs in, only the homepage, login and signup pages are available. If the user tries to nagivate to a different page, they get redirected. Similary, after the user has logged in, it doesn't make sense to let them navigate back to the login page. This access control of routes is achieved by checking whether userInfo exists in the useEffect hook and redirect them accordingly.

```javascript
useEffect(() => userInfo && history.push('/dashboard'));
```

### Silent refresh of access tokens

To make user experience as smooth as possible, access tokens get refreshed in the background without prompting the user to log in again. Every time a request is made by the Apollo client, the below piece of code runs to check whether the access token has expired. If it did, a custom made callFetch function gets called to get a new one (the refresh token is stored as an HTTP only cookie, so it's automatically included in the request). In case the request fails, the user gets logged out.

```javascript
const authLink = setContext((_, { headers }) => {
  if (localStorage.getItem('accessToken')) {
    const token = localStorage.getItem('accessToken');

    if (Date.parse(localStorage.getItem('expires')) - Date.now() < 0) {
      return callFetch(headers);
    } else {
      return {
        headers: {
          ...headers,
          authorization: `Bearer ${token}`,
        },
      };
    }
  }
});
```

```javascript
async function callFetch(headers) {
  const res = await fetch('/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query: `mutation {
            accessToken {
              accessToken
              expires
            }
          }`,
    }),
  });

  const result = await res.json();

  if (result && result.errors) {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('expires');
    localStorage.removeItem('userInfo');
    return headers;
  } else {
    const { accessToken, expires } = result.data.accessToken;

    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('expires', expires);

    return {
      headers: {
        ...headers,
        authorization: `Bearer ${accessToken}`,
      },
    };
  }
}
```

### Loading animation

While the user is waiting for the server to process the request, a simple loading animation is displayed. Thanks to the way Apollo Client's useQuery and useMutation hooks work, this was rather easy to implement.

```javascript
const { data, loading, error } = useQuery(GET_USER, {
  variables: { id: userInfo.id },
});

useEffect(() => !userInfo && history.push('/login'));

if (loading) return <Loading />;
if (error) return <Error />;
```

The custom loading component

```javascript
import Loader from 'react-loader-spinner';

const Loading = () => (
  <div
    style={{
      width: '100%',
      display: 'flex',
      justifyContent: 'center',
      margin: 'auto',
    }}
  >
    <Loader type="ThreeDots" color="#25ac64" height={100} width={100} />
  </div>
);

export default Loading;
```

### Popup messages

If the user gives wrong input in the login and signup form, a custom made Popup component shows up. The same component is used to let the user know when they successfully followed / unfollowed someone.

```javascript
const PopupMessage = ({ message, timeout, type }) => {
  const [showMessage, setShowMessage] = useState(true);

  useEffect(() => {
    let timer = setTimeout(() => {
      setShowMessage(false);
    }, timeout);

    return () => {
      clearTimeout(timer);
    };
  }, [timeout, setShowMessage]);

  return (
    <div
      className={'popup-message type-' + type}
      style={{ display: showMessage ? 'block' : 'none' }}
    >
      {message}
    </div>
  );
};
```

### User validation on the backend

For token generation and signing, I used the jwt module. For authenticating tokens, I wrote a custom authenticateToken function that returns the user object if the validation is successful and returns null otherwise.

```javascript
const generateAccessToken = (user) => {
  return jwt.sign(user, process.env.ACCESS_TOKEN_SECRET, {
    expiresIn: '15m',
  });
};

function authenticateToken(token, type = process.env.ACCESS_TOKEN_SECRET) {
  let result = null;
  jwt.verify(token, type, (err, user) => {
    if (err) return null;
    result = user;
  });
  return result;
}
```

Example of using the authenticateToken function

```javascript
const token = context.token;
const user = authenticateToken(token);
if (!user) throw new Error('Forbidden');
```

### Middleware used to extract the access token

By default, the GraphlQL library I used does not have access to the req and res objects, so I had to create a middleware to add them to the context. To make referring to the access token easier, I added it separately to the context.

```javascript
app.use('/graphql', (req, res) => {
  return graphqlHTTP({
    schema,
    graphiql: true,
    context: { req, res, token: getToken(req) },
  })(req, res);
});

function getToken(req) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  return token;
}
```

Example of a GraphQL resolve function

```javascript
async resolve(parent, args, context) {
  // code
}

```

[Back to the top](#cardy---flashcard-app)

## Future development

- Currently there is no way to upload pictures (deck and profile pictures). I'd like to make this feature available by using Cloudinary (which I used before in an other project) or AWS to store and fetch pictures from.
- Currently there is no way to change user information (email, username, password). This is a rather basic feature, so I'd like to add this in the future.
- Pagination for browse page and cards. Currently, this isn't an issue since there is little data in the database, but it can quickly become a problem when the app grows.
- Image and audio for the cards to help users learn even more effectively.
- Export deck feature. Decks could be exported in CSV or XML format.
- Bulk add cards. It can be a bit troublesome to add cards when you already have hundreds of them premade.
- Adding unit and integration tests by using jest and react-testing-library.
- Although storing refresh tokens as HTTP only cookies prevents Cross-site scripting (XSS) attacks (since they cannot be read by JavaScript), they are not immune to Cross Site Request Forgery (CSRF), thus it's theoretically possible to make an unwanted request on the user's behalf, should they fall victim of social engineering. Two ways of making the website more secure would be: (1) invalidating refresh tokens when the user logs out [can be done by storing the current valid refresh tokens in the database] (2) implementing CSRF protection by using CSRF tokens.

[Back to the top](#cardy---flashcard-app)
